# -*- coding: utf-8 -*-
"""Analises.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10VMUOYY1bbtotoETciOqPux5BTzSiNtH

![download.png](data:image/png;base64,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)

# TESTE TÉCNICO ENG. DADOS JR: 
## QUESITOS MÍNIMOS E BÔNUS

Foi proposto a análise de dados de viagens de taxi em NY de 2009 a 2012.

## Importando bibliotecas a serem usadas
"""

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import os
import requests

"""## Lendo arquivos *json diretamente da nuvem

Da forma como estavam escritos os arquivos json, 
a leitura só foi possível por linhas
"""

url ="https://s3.amazonaws.com/data-sprints-eng-test/data-sample_data-nyctaxi-trips-2009-json_corrigido.json"
trip2009 = pd.read_json(url, lines = True)

url ="https://s3.amazonaws.com/data-sprints-eng-test/data-sample_data-nyctaxi-trips-2010-json_corrigido.json"
trip2010 = pd.read_json(url, lines = True)

url ="https://s3.amazonaws.com/data-sprints-eng-test/data-sample_data-nyctaxi-trips-2011-json_corrigido.json"
trip2011 = pd.read_json(url, lines = True)

url ="https://s3.amazonaws.com/data-sprints-eng-test/data-sample_data-nyctaxi-trips-2012-json_corrigido.json"
trip2012 = pd.read_json(url, lines = True)

"""## Concatenando e filtrando os dados de interesse"""

trips_all=pd.concat([trip2009,trip2010,trip2011,trip2012])
trips_all=trips_all[['vendor_id','pickup_datetime','dropoff_datetime',
                   'pickup_longitude', 'pickup_latitude',
                   'dropoff_longitude', 'dropoff_latitude','passenger_count',
                   'trip_distance','payment_type','fare_amount', 'tip_amount',
                   'total_amount']]

"""## RESOLVENDO QUESTÃO 1

**1. Qual a distância média percorrida por viagens com no máximo 2 passageiros?**

Usando sql para selecionar trips com 2 ou menos passageiros
"""

from sqlite3 import connect
conn = connect(':memory:')
trips_all.to_sql('data_all', conn) 
    
trips_upto2p=pd.read_sql('SELECT trip_distance, passenger_count FROM data_all WHERE passenger_count <=2 ', conn)
mean_trips=pd.read_sql('SELECT AVG(trip_distance) FROM data_all WHERE passenger_count <=2 ', conn)
mean_trips=mean_trips.iloc[0,0]
conn.close()

"""Plotando as distâncias percorridas em cada viagem"""

y1=trips_upto2p['trip_distance']
x1=pd.Series(np.linspace(0,len(y1),len(y1)))
y2=mean_trips

fig=plt.figure(figsize = (10, 5));
ax=fig.add_subplot(111);
ax.set(title='Trips up to 2 passengers distribuition')
plt.xlabel('Trips')
plt.ylabel('Trip Distance')
ax.plot(x1,y1,'bo', markersize=0.006)
plt.axhline(y=y2,color='r',linewidth=3,label='Mean distance ='+str(round(mean_trips,2)))
plt.legend(loc='upper right');
plt.show();

"""### RESOLVENDO QUESTÃO 2
**2. Quais os 3 maiores vendors em quantidade total de dinheiro arrecadado?**

Lendo o arquivo com as informações sobre as siglas por tipos de pagamentos
"""

url = 'https://s3.amazonaws.com/data-sprints-eng-test/data-vendor_lookup-csv.csv'
vendors_name=pd.read_csv(url)

"""Usando sql para fazer a soma da quantia arrecadada por vendedor"""

from sqlite3 import connect
conn = connect(':memory:')
trips_all.to_sql('data_all', conn) 
vendors_amounts=pd.read_sql('SELECT SUM(total_amount), vendor_id FROM data_all GROUP BY vendor_id', conn)

conn.close()

Best=vendors_amounts.sort_values('SUM(total_amount)',ascending=False).nlargest(3, 'SUM(total_amount)')
Best['name']=vendors_name['name']

fig = plt.figure(figsize = (10, 5))
plt.bar(Best['name'], Best['SUM(total_amount)'],
        width = 0.4) 
plt.xlabel("Best 3 vendors")
plt.ylabel("Total Amount")
plt.title("Trips from 2009 to 2012")
plt.show()

"""### RESOLVENDO QUESTÃO 3:
    
**3. Faça um histograma da distribuição mensal, nos 4 anos, de corridas pagas em dinheiro**

Lendo o arquivo com as informações dos tipos pagamentos
"""

url = 'https://s3.amazonaws.com/data-sprints-eng-test/data-payment_lookup-csv.csv'
trip_pay_meth=pd.read_csv(url)

trip_pay_meth=trip_pay_meth.loc[trip_pay_meth['B']=='Cash',['A']]
trip_pay_meth=pd.DataFrame(trip_pay_meth['A'])
trip_pay_meth=trip_pay_meth['A'].astype(str).values.tolist()

"""Selecionando somente as viagens pagas em dinheiro"""

trip2009_cash=trip2009.loc[trip2009['payment_type'].isin(trip_pay_meth),['dropoff_datetime']]
trip2010_cash=trip2010.loc[trip2010['payment_type'].isin(trip_pay_meth),['dropoff_datetime']]
trip2011_cash=trip2011.loc[trip2011['payment_type'].isin(trip_pay_meth),['dropoff_datetime']]
trip2012_cash=trip2012.loc[trip2012['payment_type'].isin(trip_pay_meth),['dropoff_datetime']]

trip2009_cash['dropoff_datetime'] = trip2009_cash['dropoff_datetime'].astype("datetime64")
trip2010_cash['dropoff_datetime'] = trip2010_cash['dropoff_datetime'].astype("datetime64")
trip2011_cash['dropoff_datetime'] = trip2011_cash['dropoff_datetime'].astype("datetime64")
trip2012_cash['dropoff_datetime'] = trip2012_cash['dropoff_datetime'].astype("datetime64")

"""Contabilizando quantas viagens foram feitas a cada mês de cada ano"""

trip2009_cash=trip2009_cash.groupby(trip2009_cash['dropoff_datetime'].dt.month).count()
trip2010_cash=trip2010_cash.groupby(trip2010_cash['dropoff_datetime'].dt.month).count()
trip2011_cash=trip2011_cash.groupby(trip2011_cash['dropoff_datetime'].dt.month).count()
trip2012_cash=trip2012_cash.groupby(trip2012_cash['dropoff_datetime'].dt.month).count()

"""Plotando em gráficos de barra"""

#Largura das barras
barWidth = 0.20
fig = plt.subplots(figsize =(10, 5)) 

#Posição das barras
br2009 = np.arange(len(trip2009_cash))
br2010 = [x + barWidth for x in br2009]
br2011 = [x + barWidth for x in br2010]
br2012 = [x + barWidth for x in br2011]

y1=trip2009_cash['dropoff_datetime']
y2=trip2010_cash['dropoff_datetime']
y3=trip2011_cash['dropoff_datetime']
y4=trip2012_cash['dropoff_datetime']

#Garantindo as mesmas dimensões entre os dataframes
y1=np.pad(y1, ((0,12-len(y1))), mode='constant')
y2=np.pad(y2, ((0,12-len(y2))), mode='constant')
y3=np.pad(y3, ((0,12-len(y3))), mode='constant')
y4=np.pad(y4, ((0,12-len(y4))), mode='constant')


#Plotando
plt.bar(br2009, y1, color ='y', width = barWidth,
        edgecolor ='yellow', label ='2009')
plt.bar(br2010, y2, color ='b', width = barWidth,
        edgecolor ='blue', label ='2010')
plt.bar(br2011, y3, color ='r', width = barWidth,
        edgecolor ='red', label ='2011')
plt.bar(br2012, y4, color ='g', width = barWidth,
        edgecolor ='green', label ='2012')
 
#Colocando legendas
plt.xlabel('Months', fontweight ='bold', fontsize = 15)
plt.ylabel('Numbers of cash trips', fontweight ='bold', fontsize = 15)
plt.xticks([r + barWidth for r in range(len(trip2009_cash))],
        ['Jan', 'Fev', 'Mar', 'Abr', 'Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'],rotation=30)
 
plt.legend()
plt.show();

"""### RESOLVENDO QUESTÃO 4
**4. Faça um gráfico de série temporal contando a quantidade de gorjetas de cada dia, nos últimos 3 meses de 2012.**

Considerando que as gorjetas são pagas no final da corrida, foram selecionadas as quantias pagas em 2012 usando como referência as datas de checkout
"""

trip_2012=trip2012[['dropoff_datetime','tip_amount']]
trip_2012['dropoff_datetime'] = trip_2012['dropoff_datetime'].astype("datetime64")

"""Estabelecendo a data de inicio e fim do último trimestre"""

start_date='09-01-2012'
end_date='12-31-2012'
start_date = datetime.strptime(start_date,'%m-%d-%Y')
end_date = datetime.strptime(end_date,'%m-%d-%Y')

pd.options.mode.chained_assignment = None
trip_4rdQ2012=trip_2012.loc[(trip_2012['dropoff_datetime']>=start_date) & (trip_2012['dropoff_datetime']<=end_date)]
trip_4rdQ2012=trip_4rdQ2012.dropna()
trip_4rdQ2012= trip_4rdQ2012.sort_values('dropoff_datetime', ascending=True)

"""Somando valor total de gorjetas de cada dia"""

tip_per_day=trip_4rdQ2012.groupby(trip_4rdQ2012['dropoff_datetime'].dt.date).sum()

"""Criando o eixo do tempo"""

date_days = pd.DataFrame(tip_per_day.index)

fig=plt.figure(figsize = (10, 5))
plt.xlabel("Days from September to December 2012")
plt.ylabel("Total Amount per day")
plt.title("Tips on 4th Quarter 2012")
plt.plot(date_days,tip_per_day)
plt.xticks(rotation=30);
# obs: não há registro de corridas em novembro nem dezembro por isso não aparecem esses meses no gráfico

"""## RESOLVENDO QUESTÃO 1 - BONUS
 
**1.  Qual o tempo médio das corridas nos dias de sábado e domingo**

Selecionando colunas de interesse e mudando pro formato de data
"""

trips_delta=trips_all[['pickup_datetime','dropoff_datetime']]
trips_delta[['dropoff_datetime','pickup_datetime']] = trips_delta[['dropoff_datetime','pickup_datetime']].apply(pd.to_datetime)

#Subtraindo a hora de chegada menos saída e passando pra minutos
trips_delta['Delta_min'] = (trips_delta['dropoff_datetime'] - trips_delta['pickup_datetime']).dt.seconds/60

"""Selecionando somente as corridas de final de semana tendo como referência a data de pickup do passageiro"""

#Descobrindo o dia da semana de quando o passageiro entrou no carro
trips_delta['day_of_week'] = pd.to_datetime(trips_delta['pickup_datetime'])
trips_delta['day_of_week'] = trips_delta['day_of_week'].dt.day_name()

#Selecionando somente informações dos dias de sábado e domingo
trips_weekends=trips_delta.loc[((trips_delta['day_of_week']=='Sunday')|(trips_delta['day_of_week']=='Saturday')),['Delta_min']]

#Calculando a média de tempo
mean_weekend=trips_weekends['Delta_min'].mean()

#Plotando as distancias
y1=trips_weekends['Delta_min']
x1=pd.Series(np.linspace(0,len(y1),len(y1)))
y2=mean_weekend

mean_label=datetime.utcfromtimestamp(y2*60)
mean_label = mean_label.strftime("%M:%S")

fig=plt.figure(figsize = (10, 5))
ax=fig.add_subplot(111)
ax.set(title='Trip duration on weekends')
plt.xlabel('Trips')
plt.ylabel('Trip Duration in minutes')
plt.axhline(y=y2,color='r',linewidth=3,label='Mean duration= '+str(mean_label))
plt.legend()
ax.plot(x1,y1,'bo', markersize=0.006);

"""## RESOLVENDO QUESTAO 2 - BONUS
 
**2.  Fazer uma visualização em mapa com latitude e longitude de pickups and dropoffs no ano
 de 2010** 

"""

# Selecionando as colunas de interesse
trips_pickups=trip2010[['pickup_longitude', 'pickup_latitude']]
trips_dropoffs=trip2010[['dropoff_longitude', 'dropoff_latitude']]


fig = plt.subplots(figsize =(10, 5)) 
ax.set(title='Geolocal trips in 2010')

plt.scatter(x=trips_dropoffs['dropoff_longitude'], y=trips_dropoffs['dropoff_latitude'],color='b',label ='Dropoffs')
plt.scatter(x=trips_pickups['pickup_longitude'], y=trips_pickups['pickup_latitude'],color='r',label ='Pickups')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.legend(loc='center right')
plt.show()